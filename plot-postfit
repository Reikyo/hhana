#!/usr/bin/env python

# python imports
import os
import pickle
import logging

from tabulate import tabulate

# ROOT/rootpy imports
from ROOT import TLatex, TGraphAsymmErrors, TH1 
from rootpy import asrootpy
from rootpy.io import root_open
from rootpy.plotting import Canvas, HistStack, Graph, Legend, set_style
from rootpy.plotting.utils import draw
from rootpy.plotting.style.atlas import ATLAS_style, ATLAS_label
from rootpy.utils.path import mkdir_p
from rootpy.extern.tabulartext import PrettyTable

# local imports
from mva import ATLAS_LABEL, MMC_MASS
from mva.categories import CATEGORIES
from mva.analysis import Analysis
from mva.templates import RatioPlot
from mva.variables import get_label

from statstools.fitresult import Prefit_RooFitResult
from statstools.postfit import FitModel, ModelCalculator
from statstools.jobs import run_pool
from statstools.plotting import (get_uncertainty_graph, parse_name,
                                 get_category, get_binning, get_blinding,
                                 get_rebinned_graph, get_rebinned_hist)

log = logging.getLogger(os.path.basename(__file__))


def fit_workspace(file_name, ws_name,
                  output_basename='frames',
                  n_jobs=-1):
    """
    Fit the WS and compute the histograms and TGraphAssymErrors
    for the final plotting drawing

    Parameters
    ----------
    workspace : RooWorkspace
        HSG4 like workspace

    """
    with root_open(file_name) as file0:
        workspace = file0[ws_name]
        mc = workspace.obj("ModelConfig")
        obsData = workspace.data('obsData')
        workspace.saveSnapshot('StartingPoint', mc.GetPdf().getParameters(obsData))
        roo_min = workspace.fit()
        fit_res = roo_min.save()
        cats =  [cat for cat in mc.GetPdf()]
    
        output_root = output_basename + '.root'
        output_pickle = output_basename + '.pickle'
        log.info('Output: {0}'.format(output_root))
        log.info('Output: {0}'.format(output_pickle))
        root_open(output_root, 'recreate').Close()
        with open(output_pickle, 'w') as pickle_file:
            pickle.dump({}, pickle_file)
        workers = []
        # workspace.loadSnapshot('StartingPoint')
        # fit_res = Prefit_RooFitResult(fit_res, True)
        for cat in cats:
            log.info('retrieve plotting objects of {0} ...'.format(cat.name))
            workers.append(ModelCalculator(file0, workspace, cat, fit_res,
                                           output_root, output_pickle))
        run_pool(workers, n_jobs=n_jobs)
        

def plot_from_frame(file, name, fit_var, category, year,
                    binning=None, unblind=True, path=None):
    ana = Analysis(2012)
    frame = file[name]
    hbkg = file.Get('h_sum_bkg_{0}'.format(frame.GetName()))
    curve_uncert_bkg = frame.getCurve('FitError_AfterFit_sum_bkg_{0}'.format(frame.GetName()))
    graph_bkg_ws = get_uncertainty_graph(hbkg, curve_uncert_bkg)
    graph_bkg = get_rebinned_graph(graph_bkg_ws, binning, unblind=True) 
    graph_bkg.fillstyle = '//'
    graph_bkg.color = 'black'
    graph_bkg.name = 'Background'
    graph_bkg.title = 'Uncert.'
    graph_bkg.legendstyle = 'F'
    graph_bkg.drawstyle = 'E2'

    data_ws = frame.getHist('Data')
    # HACK HACK HACK
    data_ws.__class__ = TGraphAsymmErrors
    data = get_rebinned_graph(asrootpy(data_ws), binning, unblind=unblind)
    data.name = 'Data'
    data.title = 'Data'
    data.drawstyle = 'PE'
    data.legendstyle = 'LEP'

    hist_fake_ws = file.Get('h_Fakes_{0}'.format(frame.GetName()))
    hist_fake = get_rebinned_hist(hist_fake_ws, binning)
    hist_fake.color = ana.qcd.hist_decor['color']
    hist_fake.fillstyle = 'solid'
    hist_fake.name = 'Fakes'
    hist_fake.title = ana.qcd.label
    hist_fake.legendstyle = 'F'
    
    curve_uncert_fakes = frame.getCurve('FitError_AfterFit_Fakes_{0}'.format(frame.GetName()))
    graph_fakes_ws = get_uncertainty_graph(hist_fake_ws, curve_uncert_fakes)
    graph_fakes = get_rebinned_graph(graph_fakes_ws, binning, unblind=True) 
    graph_fakes.name = 'Fakes'

    hist_others_ws = file.Get('h_Others_{0}'.format(frame.GetName()))
    hist_others = get_rebinned_hist(hist_others_ws, binning)
    hist_others.color = ana.others.hist_decor['color']
    hist_others.fillstyle = 'solid'
    hist_others.name = 'Others'
    hist_others.title = ana.others.label
    hist_others.legendstyle = 'F'
    curve_uncert_others = frame.getCurve('FitError_AfterFit_Others_{0}'.format(frame.GetName()))
    graph_others_ws = get_uncertainty_graph(hist_others_ws, curve_uncert_others)
    graph_others = get_rebinned_graph(graph_others_ws, binning, unblind=True) 
    graph_others.name = 'Others'

    hist_ztautau_ws = file.Get('h_Ztautau_{0}'.format(frame.GetName()))
    hist_ztautau = get_rebinned_hist(hist_ztautau_ws, binning)
    hist_ztautau.color = ana.ztautau.hist_decor['color']
    hist_ztautau.fillstyle = 'solid'
    hist_ztautau.name = 'Ztautau'
    hist_ztautau.title = ana.ztautau.label
    hist_ztautau.legendstyle = 'F'
    curve_uncert_ztautau = frame.getCurve('FitError_AfterFit_Ztautau_{0}'.format(frame.GetName()))
    graph_ztautau_ws = get_uncertainty_graph(hist_ztautau_ws, curve_uncert_ztautau)
    graph_ztautau = get_rebinned_graph(graph_ztautau_ws, binning, unblind=True) 
    graph_ztautau.name = 'Ztautau'
    
    hist_signal_ws = file.Get('h_sum_sig_{0}'.format(frame.GetName()))
    hist_signal = get_rebinned_hist(hist_signal_ws, binning)
    hist_signal.color = ana.higgs_125.hist_decor['linecolor']
    hist_signal.linestyle = 'solid'
    hist_signal.linewidth = 4
    hist_signal.name = 'Signal'
    hist_signal.title = ana.higgs_125.label + ' (best fit #mu)'
    hist_signal.legendstyle = 'F'

    background = [hist_fake, hist_others, hist_ztautau]
    hists = background[:]
    if unblind is True and not isinstance(unblind, int):
        hists.append(hist_signal)

    model = HistStack(hists=hists,
                      name='Model_{0}'.format(frame.GetName()))

    # TODO: make plot identical to standard variable plots
    if fit_var == 'bdt':
        if category.name == 'rest':
            xtitle = get_label('dEta_tau1_tau2') 
        else:
            xtitle = 'BDT Score'
        categories = CATEGORIES['mva_all']
    else:
        xtitle = get_label(MMC_MASS)
        categories = CATEGORIES['cuts'] + CATEGORIES['cuts_2011']
    
    if year == 2011:
        sqrts = 7
    else:
        sqrts = 8

    plottables = [
        model,
        graph_bkg,
        data,
    ]
    
    ratio = data / graph_bkg
    ratio.drawstyle = 'EP'
    
    for logy in (False, True):
        plot_name = 'postfit_{0}'.format(name)
        canvas = RatioPlot(
            xtitle=xtitle,
            ytitle='Events',
            ratio_title='Data / Model',
            ratio_range=(0, 2),
            ratio_line_values=[0.5, 1, 1.5],
            logy=logy)
        if logy:
            plot_name += '_logy'
        canvas.draw('main', plottables, ypadding=(0.3, 0.3))
        canvas.draw('ratio', ratio)
        x, y = canvas.axes('main')
        x.limits = model[0].bounds()
        x.range_user = model[0].bounds()
        x, y = canvas.axes('ratio')
        x.limits = model[0].bounds()
        x.range_user = model[0].bounds()
        canvas.update_lines()
        canvas.cd('main')
        ATLAS_label(0.2, 0.89, pad=canvas.pad('main'), sep=0.132,
                    text=ATLAS_LABEL, sqrts=sqrts)
        leg = Legend(
            [data] + model.hists[::-1] + [graph_bkg],
            leftmargin=0.45,
            margin=0.35,
            topmargin=0.05,
            textsize=20,
            entrysep=0.02,
            entryheight=0.05)
        leg.Draw()
        latex = TLatex(0.2, 0.85, category.label)
        latex.SetNDC()
        latex.SetTextSize(20)
        latex.Draw()
        for fmt in ('eps', 'png'):
            if path is None:
                canvas.SaveAs('{0}.{1}'.format(plot_name, fmt))
            else:
                canvas.SaveAs(os.path.join(path, '{0}.{1}'.format(plot_name, fmt)))
    
    # print yields table
    bin_edges = [(hist_fake.xedgesl(bin.idx), hist_fake.xedgesh(bin.idx)) for bin in hist_fake.bins()]
    postfit_table_header = ['Sample'] + [
        '{0:.2g} - {1:.2g}'.format(l, h) for l, h in bin_edges]
    postfit_table = []
    postfit_table.append(['Data'] + [str(int(val)) for val in data.y()])
    for h in [graph_bkg, graph_fakes, graph_others, graph_ztautau]:
        row = [h.name]
        for val, errh, errl in zip(h.y(), h.yerrh(), h.yerrl()):
            #row.append('{0:1.2f} ^{{+{1:1.2f}}}_{{-{2:1.2f}}}'.format(val, errh, errl))
            row.append('${0:1.2f} \pm {1:1.2f}$'.format(val, errh))
        postfit_table.append(row)
    table = tabulate(postfit_table, postfit_table_header, tablefmt='latex')
    print
    print year, category_name, mass
    print r"\begin{table}"
    print r"\centering"
    print table
    print r"\caption{Postfit yield in %s}." % category.latex 
    print r"\end{table}"
    print


if __name__ == '__main__':
    from rootpy.extern.argparse import ArgumentParser
    parser = ArgumentParser()
    parser.add_argument('file')
    parser.add_argument('--name', default='combined')
    parser.add_argument('--fit-var', default='bdt', choices=['bdt', 'mmc'])
    parser.add_argument('--force-fit', action='store_true', default=False)
    parser.add_argument('--unblind', action='store_true', default=False)
    parser.add_argument('--jobs', default=-1)
    args = parser.parse_args()

    if args.fit_var == 'bdt':
        categories = CATEGORIES['mva_all']
    else:
        categories = CATEGORIES['cuts'] + CATEGORIES['cuts_2011']

    input = os.path.splitext(args.file)[0]
    output = input + '_postfit'
    plots = input + '_plots'

    if not os.path.exists(output + '.root') or args.force_fit:
        fit_workspace(args.file, args.name, output, n_jobs=args.jobs)
    
    if not os.path.exists(plots):
        mkdir_p(plots)

    file = root_open(output + '.root')
    for _, _, names in file.walk(class_pattern='*RooPlot*'):
        for name in names:
            log.info('Channel: {0}'.format(name))
            year, category_name, mass = parse_name(name)
            log.info('Year: {0}; Mass: {1}; Category: {2}'.format(
                year, mass, category_name))
            category = get_category(category_name, categories)
            if category is None:
                # not found
                log.warning("skipping category: {0}".format(category_name))
                continue
            binning = get_binning(category, year, fit_var=args.fit_var)
            if category_name != 'rest' and not args.unblind:
                unblind = get_blinding(category, year, fit_var=args.fit_var)
                log.info('Blinding region: {0}'.format(unblind))
            else:
                unblind = args.unblind
            plot_from_frame(file, name, args.fit_var,
                            category, year, binning,
                            unblind=unblind,
                            path=plots)
    file.Close()
