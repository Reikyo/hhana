#!/usr/bin/env python

"""
This performs the so-called "track fit" to determine the QCD and Z normalization
in each of the categories. These normalizations are cached in cache/norms.cache
and later used by the rest of the analysis framework.

For a list of all options this script accepts please see::

    ./norm --help
"""

from mva.cmd import fit_parser

parser = fit_parser()
args = parser.parse_args()

from rootpy.plotting import Hist2D

from mva.samples import Data, MC_Ztautau, Embedded_Ztautau, Others, QCD
from mva.stats import histfactory
from mva.massregions import MassRegions
from mva.norm import cache, log
from mva.plotting import draw_samples
from mva.systematics import SYSTEMATICS
from mva.categories import CATEGORIES
from matplotlib.ticker import FuncFormatter

import ROOT
from ROOT import RooMinimizer

# fit the 2D recounted number of track distribution
expr = 'tau1_numTrack_recounted:tau2_numTrack_recounted'
# define the 2D boundaries and number of bins
min_edge, max_edge = .5, 4.5
bins = int(max_edge - min_edge)
# define the histogram template
hist_template = Hist2D(bins, min_edge, max_edge,
                       bins, min_edge, max_edge)

def xtick_func(x, pos):
    # used by matplotlib to label the x axis with the (#track1, #track2) tuples 
    ntrack1 = int((x - 1) / bins) + 1
    ntrack2 = (x - 1) % bins + 1
    return "(%d,%d)" % (ntrack1, ntrack2)

track_formatter = FuncFormatter(xtick_func)

before_name = "bkg_before_fit"
after_name = "bkg_after_fit"

year = 2012
param = 'TRACK'
mass_regions = MassRegions(low_cutoff=70, low=100, high=180,
                           high_sideband_in_control=False)

# The year param below should eventually be given by the user from the command
# line (defaulting to 2012) but currently is hard coded as 2012
data = Data(2012)
if args.embedding:
    # Use embedded Z->tau+tau
    ztt = Embedded_Ztautau(2012, systematics=True)
    before_name += '_embedded'
    after_name += '_embedded'
else:
    # Use ALPGEN Z->tau+tau
    ztt = MC_Ztautau(2012, systematics=True)
others = Others(2012, systematics=True)
qcd = QCD(data, mc=(ztt, others))
qcd.label = 'QCD Multi-jet'

# loop over the categories
for category in CATEGORIES[args.categories]:
    
    log.info(data.cuts(category, 'OS'))
    
    # Initialize Z scale to (data - QCD - others) / Z
    # so we get good convergence for ALPGEN or embedded Z
    ztt.scale = 1.
    ztt.scale_error = 0.
    qcd.shape_region = 'SS'
    qcd.scale = 1.
    qcd.scale_error = 0.

    data_events = data.events(category, 'OS', cuts=mass_regions.control_region)
    qcd_events = qcd.events(category, 'OS', cuts=mass_regions.control_region)
    oth_events = others.events(category, 'OS', cuts=mass_regions.control_region)
    z_events = ztt.events(category, 'OS', cuts=mass_regions.control_region)
    scale_init = (data_events - qcd_events - oth_events) / float(z_events)
    ztt.scale = scale_init
    log.info("initial Z scale before fit: %f" % scale_init)

    # Draw the track distribution before the fit
    draw_samples(hist_template, expr,
            model=[qcd, others, ztt],
            data=data,
            category=category,
            region='OS',
            cuts=mass_regions.control_region,
            name="Recounted Number of Tracks",
            output_name=before_name,
            show_ratio=True,
            systematics=SYSTEMATICS.values(),
            ravel=True,
            integer=True,
            xtick_formatter=track_formatter,
            xtick_rotation=90)
    
    # Request HistFactory Samples for each of the model components
    ztt_sample = ztt.get_histfactory_sample(
            hist_template, expr, category, 'OS',
            cuts=mass_regions.control_region,
            systematics=False)
    others_sample = others.get_histfactory_sample(
            hist_template, expr, category, 'OS',
            cuts=mass_regions.control_region,
            systematics=False)
    qcd_sample = qcd.get_histfactory_sample(
            hist_template, expr, category, 'OS',
            cuts=mass_regions.control_region,
            systematics=False)
    data_sample = data.get_histfactory_sample(
            hist_template, expr, category, 'OS',
            cuts=mass_regions.control_region)
    
    # Define the floating norm parameters that will be fitted
    ztt_sample.AddNormFactor('z_scale', 1., 0.5, 2.0)
    qcd_sample.AddNormFactor('qcd_scale', 1., 0.5, 2.0)
    
    # Construct a HistFactory Channel and Measurement and then the Workspace
    # Note: The following is based on HistFitter code
    
    channel = histfactory.make_channel(category.name,
            [ztt_sample, others_sample, qcd_sample], data_sample.GetHisto())
    measurement = histfactory.make_measurement('trackfit', '', [channel],
            lumi_rel_error=0.028,
            POI=['z_scale', 'qcd_scale'])
    workspace = histfactory.make_model(measurement)

    # Get the observed data and model PDF
    obs_data = workspace.data('obsData')
    pdf = workspace.pdf('model_channel_%s' % category.name)

    # Construct the negative log likelihood of the PDF
    nll = pdf.createNLL(obs_data)

    # Create and configure the minimizer
    minim = RooMinimizer(nll)
    strategy = ROOT.Math.MinimizerOptions.DefaultStrategy()
    minim.setStrategy(strategy)
    tol = ROOT.Math.MinimizerOptions.DefaultTolerance()
    minim.setEps(max(tol, 1.))
    minim.setPrintLevel(0)
    minim.optimizeConst(2)
    minimizer = ROOT.Math.MinimizerOptions.DefaultMinimizerType()
    algorithm = ROOT.Math.MinimizerOptions.DefaultMinimizerAlgo()
    status = -1

    tries = 1
    maxtries = 4
    
    # Perform the minimization
    while tries <= maxtries:
        status = minim.minimize(minimizer, algorithm)
        if status % 1000 == 0:
            # ignore errors from Improve
            break
        elif tries == 1:
                # doing a re-scan first
                minim.minimize(minimizer, "Scan")
        elif tries == 2:
            if ROOT.Math.MinimizerOptions.DefaultStrategy() == 0:
                # trying with strategy = 1
                minim.setStrategy(1)
            else:
                # skip this trial if stratehy is already 1
                tries += 1
        elif tries == 3:
            # trying with improved migrad
            minimizer = "Minuit";
            algorithm = "migradimproved";

    fit_result = minim.save()
    
    # Get the fitted Z and QCD normalizations and associated uncertainties
    z_scale_arg = fit_result.floatParsFinal().find("z_scale")
    z_scale = z_scale_arg.getValV() * scale_init
    z_scale_error = z_scale_arg.getError() * scale_init

    qcd_scale_arg = fit_result.floatParsFinal().find("qcd_scale")
    qcd_scale = qcd_scale_arg.getValV()
    qcd_scale_error = qcd_scale_arg.getError()
    
    # Cache the fitted normalization scale factors

    # SS_TRK QCD model
    cache.set_scales(
            year,
            category.name, args.embedding, param,
            'SS_TRK',
            qcd_scale, qcd_scale_error,
            z_scale, z_scale_error)
    
    ztt.scale = z_scale
    ztt.scale_error = z_scale_error

    # nOS QCD model
    # Correct the QCD scale to account for difference between fitting model
    # and target model (SS vs !OS)
    # The final OS model includes the requirement that the number of recounted
    # tracks equals 1 or 3 for both taus, so we need to scale the QCD to what would
    # be expected after this requirement
    # Note: All regions are defined in mva/regions.py
    qcd.shape_region = 'SS_TRK'
    qcd_events = qcd.events(category, 'OS')#, cuts=mass_regions.control_region)
    qcd.shape_region = 'nOS'
    qcd_events_target = qcd.events(category, 'OS')#, cuts=mass_regions.control_region)
    qcd.shape_region = 'SS'
    qcd_scale_corrected = qcd_events / qcd_events_target
    cache.set_scales(
            year,
            category.name, args.embedding, param,
            'nOS',
            qcd_scale * qcd_scale_corrected,
            qcd_scale_error * qcd_scale_corrected,
            z_scale, z_scale_error)
        
    qcd.scale = qcd_scale
    qcd.scale_error = qcd_scale_error
    
    # Draw the track distribution after the fit
    draw_samples(hist_template, expr,
            model=[qcd, others, ztt],
            data=data,
            category=category,
            region='OS',
            cuts=mass_regions.control_region,
            name="Recounted Number of Tracks",
            output_name=after_name,
            show_ratio=True,
            systematics=SYSTEMATICS.values(),
            ravel=True,
            integer=True,
            xtick_formatter=track_formatter,
            xtick_rotation=90)
