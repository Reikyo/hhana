#!/usr/bin/env python

"""
This performs the so-called "track fit" to determine the QCD and Z normalization
in each of the categories. These normalizations are cached in cache/norms.cache
and later used by the rest of the analysis framework.
"""

from mva.cmd import fit_parser

parser = fit_parser()
args = parser.parse_args()

from rootpy.plotting import Hist2D

from mva.samples import Data, MC_Ztautau, Embedded_Ztautau, Others, QCD
from mva.stats import histfactory
from mva.massregions import MassRegions
from mva.norm import cache
from mva.plotting import draw_samples
from mva.systematics import SYSTEMATICS
from mva.categories import CATEGORIES
from matplotlib.ticker import FuncFormatter

import ROOT
from ROOT import RooMinimizer


expr = 'tau1_numTrack_recounted:tau2_numTrack_recounted'
min_edge, max_edge = .5, 4.5
bins = int(max_edge - min_edge)

hist_template = Hist2D(bins, min_edge, max_edge,
                       bins, min_edge, max_edge)

def xtick_func(x, pos):
    
    ntrack1 = int((x - 1) / bins) + 1
    ntrack2 = (x - 1) % bins + 1
    return "(%d,%d)" % (ntrack1, ntrack2)

track_formatter = FuncFormatter(xtick_func)

before_name = "bkg_before_fit"
after_name = "bkg_after_fit"

# no track cuts in regions
region = 'OS'
fit_qcd_shape_region = 'SS'
virtual_qcd_shape_region = 'SS_TRK'
target_qcd_shape_region = args.qcd_shape_region
before_name += '_' + target_qcd_shape_region
after_name += '_' + target_qcd_shape_region
year = 2012
param = 'TRACK'
mass_regions = MassRegions(110, 180, True)

data = Data(2012)
if args.embedding:
    ztt = Embedded_Ztautau(2012, systematics=True)
    before_name += '_embedded'
    after_name += '_embedded'
else:
    ztt = MC_Ztautau(2012, systematics=True)
others = Others(2012, systematics=True)
qcd = QCD(data, mc=(ztt, others))


for category in CATEGORIES[args.categories]:
    
    # initialize Z scale to (data - QCD - others) / Z
    # so we get good convergence for ALPGEN or embedded Z
    ztt.scale = 1.
    ztt.scale_error = 0.
    qcd.shape_region = fit_qcd_shape_region
    qcd.scale = 1.
    qcd.scale_error = 0.

    data_events = data.events(category, region, cuts=mass_regions.control_region)
    qcd_events = qcd.events(category, region, cuts=mass_regions.control_region)
    oth_events = others.events(category, region, cuts=mass_regions.control_region)
    z_events = ztt.events(category, region, cuts=mass_regions.control_region)
    scale_init = (data_events - qcd_events - oth_events) / float(z_events)
    ztt.scale = scale_init

    # draw before fit
    draw_samples(hist_template, expr,
            model=[qcd, others, ztt],
            data=data,
            category=category,
            region=region,
            cuts=mass_regions.control_region,
            name="Recounted Number of Tracks",
            output_name=before_name,
            show_ratio=True,
            systematics=SYSTEMATICS.values(),
            ravel=True,
            integer=True,
            xtick_formatter=track_formatter,
            xtick_rotation=90)
    
    ztt_sample = ztt.get_histfactory_sample(
            hist_template, expr, category, region,
            cuts=mass_regions.control_region,
            systematics=False)
    others_sample = others.get_histfactory_sample(
            hist_template, expr, category, region,
            cuts=mass_regions.control_region,
            systematics=False)
    qcd_sample = qcd.get_histfactory_sample(
            hist_template, expr, category, region,
            cuts=mass_regions.control_region,
            systematics=False)
    data_sample = data.get_histfactory_sample(
            hist_template, expr, category, region,
            cuts=mass_regions.control_region)

    ztt_sample.AddNormFactor('z_scale', 1., 0.5, 2.0)
    qcd_sample.AddNormFactor('qcd_scale', 1., 0.5, 2.0)

    channel = histfactory.make_channel(category.name,
            [ztt_sample, others_sample, qcd_sample], data_sample.GetHisto())
    measurement = histfactory.make_measurement('trackfit', '', [channel],
            lumi_rel_error=0.028,
            POI=['z_scale', 'qcd_scale'])
    
    # The following is based on HistFitter code
    workspace = histfactory.make_model(measurement)

    obs_data = workspace.data('obsData')
    pdf = workspace.pdf('model_channel_%s' % category.name)

    nll = pdf.createNLL(obs_data)
    minim = RooMinimizer(nll)
    strategy = ROOT.Math.MinimizerOptions.DefaultStrategy()
    minim.setStrategy(strategy)
    tol = ROOT.Math.MinimizerOptions.DefaultTolerance()
    minim.setEps(max(tol, 1.))
    minim.setPrintLevel(0)
    minim.optimizeConst(2)
    minimizer = ROOT.Math.MinimizerOptions.DefaultMinimizerType()
    algorithm = ROOT.Math.MinimizerOptions.DefaultMinimizerAlgo()
    status = -1

    tries = 1
    maxtries = 4

    while tries <= maxtries:
        status = minim.minimize(minimizer, algorithm)
        if status % 1000 == 0:
            # ignore errors from Improve
            break
        elif tries == 1:
                # doing a re-scan first
                minim.minimize(minimizer, "Scan")
        elif tries == 2:
            if ROOT.Math.MinimizerOptions.DefaultStrategy() == 0:
                # trying with strategy = 1
                minim.setStrategy(1)
            else:
                # skip this trial if stratehy is already 1
                tries += 1
        elif tries == 3:
            # trying with improved migrad
            minimizer = "Minuit";
            algorithm = "migradimproved";

    fit_result = minim.save()

    z_scale_arg = fit_result.floatParsFinal().find("z_scale")
    z_scale = z_scale_arg.getValV() * scale_init
    z_scale_error = z_scale_arg.getError() * scale_init

    qcd_scale_arg = fit_result.floatParsFinal().find("qcd_scale")
    qcd_scale = qcd_scale_arg.getValV()
    qcd_scale_error = qcd_scale_arg.getError()

    if target_qcd_shape_region != virtual_qcd_shape_region:
        # correct QCD scale to account for difference between fitting model and
        # target model (SS vs !OS)
        qcd.shape_region = virtual_qcd_shape_region
        qcd_events = qcd.events(category, region)#, cuts=mass_regions.control_region)
        qcd.shape_region = target_qcd_shape_region
        qcd_events_target = qcd.events(category, region)#, cuts=mass_regions.control_region)
        qcd.shape_region = fit_qcd_shape_region
        qcd_scale_corrected = qcd_events / qcd_events_target
    else:
        qcd_scale_corrected = 1.
    
    cache.set_scales(
            year,
            category.name, args.embedding, param,
            target_qcd_shape_region,
            qcd_scale * qcd_scale_corrected,
            qcd_scale_error * qcd_scale_corrected,
            z_scale, z_scale_error)
    
    ztt.scale = z_scale
    ztt.scale_error = z_scale_error
    qcd.scale = qcd_scale
    qcd.scale_error = qcd_scale_error

    # draw after fit
    draw_samples(hist_template, expr,
            model=[qcd, others, ztt],
            data=data,
            category=category,
            region=region,
            cuts=mass_regions.control_region,
            name="Recounted Number of Tracks",
            output_name=after_name,
            show_ratio=True,
            systematics=SYSTEMATICS.values(),
            ravel=True,
            integer=True,
            xtick_formatter=track_formatter,
            xtick_rotation=90)
