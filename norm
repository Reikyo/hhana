#!/usr/bin/env python

"""
This performs the so-called "track fit" to determine the QCD and Z normalization
in each of the categories. These normalizations are cached in cache/norms.cache
and later used by the rest of the analysis framework.

For a list of all options this script accepts please see::

    ./norm --help
"""

from mva.cmd import fit_parser

parser = fit_parser()
args = parser.parse_args()

import sys

from rootpy.io import root_open
from rootpy.plotting import Hist2D, Hist

from mva.analysis import Analysis
from mva.stats import histfactory
from mva.stats.fit import fit
from mva.massregions import MassRegions
from mva.norm import cache, log
from mva.plotting import draw_samples
from mva.systematics import SYSTEMATICS
from mva.categories import CATEGORIES

from matplotlib.ticker import FuncFormatter

import ROOT
from ROOT import RooMinimizer
ROOT.gSystem.Load('libTrackFit.so')


# fit the 2D recounted number of track distribution
expr = 'tau1_numTrack_recounted:tau2_numTrack_recounted'
# define the 2D boundaries and number of bins
min_edge, max_edge = .5, 4.5
bins = int(max_edge - min_edge)
integer = True
xaxis_label = "Recounted Number of Tracks"

# define the histogram template
hist_template = Hist2D(bins, min_edge, max_edge,
                       bins, min_edge, max_edge, type='D')

# SS-OSff from Daniele
qcd_syst = hist_template.Clone()
qcd_syst[0,0] = 1.08208
qcd_syst[0,1] = 0.975144
qcd_syst[0,2] = 0.990815
qcd_syst[0,3] = 0.90673
qcd_syst[1,0] = 0.969593
qcd_syst[1,1] = 1.04061
qcd_syst[1,2] = 0.918478
qcd_syst[1,3] = 0.921596
qcd_syst[2,0] = 1.0181
qcd_syst[2,1] = 0.944523
qcd_syst[2,2] = 0.840268
qcd_syst[2,3] = 1.08005
qcd_syst[3,0] = 0.942919
qcd_syst[3,1] = 0.85719
qcd_syst[3,2] = 0.977043
qcd_syst[3,3] = 0.92383


def xtick_track_func(x, pos):
    # used by matplotlib to label the x axis with the (#track1, #track2) tuples 
    ntrack1 = int((x - 1) / bins) + 1
    ntrack2 = (x - 1) % bins + 1
    return "(%d,%d)" % (ntrack1, ntrack2)

xtick_formatter = FuncFormatter(xtick_track_func)
xtick_rotation = 90
param = 'TRACK'

mass_regions = MassRegions(low_cutoff=60, low=100, high=180,
                           high_sideband_in_control=False)
control_region = None
#control_region = mass_regions.control_region

fit_region = 'SS'
fit_region_alias = 'SS_TRK'
target_region = 'nOS'
virtual_region = 'SS_TRK'
model_region = 'OS'

before_name = "bkg_before_%sfit" % param
after_name = "bkg_after_%sfit" % param

year = 2012

analysis = Analysis(
    year=year,
    systematics=False,
    use_embedding=args.embedding,
    qcd_shape_region=fit_region)

if args.embedding:
    before_name += '_embedded'
    after_name += '_embedded'

ztt = analysis.ztautau
data = analysis.data
others = analysis.others
qcd = analysis.qcd
qcd.label = 'QCD Multi-jet'
higgs = analysis.higgs_125

systematics = False

# loop over category definitions
for cat_def in args.categories:
    # loop over the categories
    for category in CATEGORIES[cat_def]:
        
        print
        print "=" * 40
        print category.name
        print "=" * 40
        print
        
        log.info(data.cuts(category, model_region))
        
        ztt.scale = 1.
        ztt.scale_error = 0.
        qcd.scale = 1.
        qcd.scale_error = 0.
        scale_init = 1.
        
        """
        # Initialize Z scale to (data - QCD - others) / Z
        # so we get good convergence for ALPGEN or embedded Z
        data_events = data.events(category, model_region, cuts=control_region)
        qcd_events = qcd.events(category, model_region, cuts=control_region)
        oth_events = others.events(category, model_region, cuts=control_region)
        z_events = ztt.events(category, model_region, cuts=control_region)
        scale_init = (data_events - qcd_events - oth_events) / float(z_events)
        ztt.scale = scale_init
        log.info("initial Z scale before fit: %f" % scale_init)
        """

        if args.plot:
            # Draw the distribution before the fit
            draw_samples(hist_template, expr,
                model=[qcd, others, ztt],
                data=data,
                category=category,
                region=model_region,
                cuts=control_region,
                name=xaxis_label,
                output_name=before_name,
                show_ratio=True,
                systematics=SYSTEMATICS.values() if systematics else None,
                ravel=hist_template.GetDimension() > 1,
                integer=integer,
                xtick_formatter=xtick_formatter,
                xtick_rotation=xtick_rotation)
        
        data_hist = hist_template.Clone()
        data.draw_into(data_hist, expr, category, model_region,
                cuts=control_region, systematics=False)
        
        tau_hist = hist_template.Clone() 
        ztt.draw_into(tau_hist, expr, category, model_region,
                cuts=control_region, systematics=False)
        
        others_hist = hist_template.Clone()
        others.draw_into(others_hist, expr, category, model_region,
                cuts=control_region, systematics=False)
        
        qcd_data_hist = hist_template.Clone()
        data.draw_into(qcd_data_hist, expr, category, fit_region,
                cuts=control_region, systematics=False)
        
        qcd_tau_hist = hist_template.Clone() 
        ztt.draw_into(qcd_tau_hist, expr, category, fit_region,
                cuts=control_region, systematics=False)
        
        qcd_others_hist = hist_template.Clone()
        others.draw_into(qcd_others_hist, expr, category, fit_region,
                cuts=control_region, systematics=False)

        higgs_hist = hist_template.Clone()
        higgs.draw_into(higgs_hist, expr, category, model_region,
                cuts=control_region, systematics=False)

        fitter = ROOT.TrackFit.TrackFitter()

        # QCD = C x [A x Data - B x Z - O]

        C = 2
        A = 1.
        B = 1.
        A_error = None
        B_error = None
        
        iteration = 1
        # converge on the fitted values of A and B until C is close to 1.
        while abs(C - 1) > 0.001:

            qcd_hist = qcd_data_hist * A - qcd_tau_hist * B - qcd_others_hist
            tau_hist_float = tau_hist * B

            fit_result = fitter.fit(
                data_hist, tau_hist_float, qcd_hist, others_hist, higgs_hist,
                # qcd_syst, qcd_stat
                qcd_syst, qcd_hist,
                # tau PU low, tau PU high
                tau_hist_float, tau_hist_float)
            
            C = fit_result.sf_QCD
            B *= fit_result.sf_Z
            A *= C
            
            if A_error is None:
                A_error = fit_result.sf_QCD_err
                B_error = fit_result.sf_Z_err
            else:
                A_error *= fit_result.sf_QCD
                B_error *= fit_result.sf_Z

            log.info("TrackFit iteration %d" % iteration)
            log.info("sf_QCD: %.4f +/- %.4f sf_Z: %.4f +/- %.4f" % (A, A_error, B, B_error))
            iteration += 1
        
        qcd_data_scale = A 
        qcd_data_scale_error = A_error
        
        z_scale = B * scale_init
        z_scale_error = B_error * scale_init

        # Cache the fitted normalization scale factors for SS_TRK
        cache.set_scales(
            year,
            category.name, args.embedding, param,
            fit_region_alias,
            qcd_data_scale=qcd_data_scale,
            qcd_data_scale_error=qcd_data_scale_error,
            qcd_z_scale=1.,
            qcd_others_scale=1.,
            z_scale=z_scale,
            z_scale_error=z_scale_error)
        
        """
                     nOS QCD Model
        ==========================================

                        |Data(SS_TRK)|
        QCD(nOS) =  A x -------------- x Data(nOS)
                         |Data(nOS)|

                          |Z(SS_TRK)|
                    - B x ----------- x Z(nOS)
                           |Z(nOS)|
                  
                      |Others(SS_TRK)|
                    - ---------------- x Others(nOS)
                       |Others(nOS)|
        
        Correct the QCD scale to account for difference between fitting model
        and target model (SS vs !OS). The final OS model includes the
        requirement that the number of recounted tracks equals 1 or 3
        for both taus, so we need to scale the QCD to what would be expected
        after this requirement
        
        Note: All regions are defined in mva/regions.py
        """
        sf_data   = (data.events(category, 'SS_TRK') /
                     float(data.events(category, 'nOS')))
        
        sf_ztt    = (ztt.events(category, 'SS_TRK') /
                     float(ztt.events(category, 'nOS')))
        
        sf_others = (others.events(category, 'SS_TRK') /
                     float(others.events(category, 'nOS')))

        qcd_data_scale_nos = qcd_data_scale * sf_data
        qcd_data_scale_error_nos = qcd_data_scale_error * sf_data
        qcd_z_scale_nos = sf_ztt
        qcd_others_scale_nos = sf_others

        cache.set_scales(
            year,
            category.name, args.embedding, param,
            'nOS',
            qcd_data_scale=qcd_data_scale_nos,
            qcd_data_scale_error=qcd_data_scale_error_nos,
            qcd_z_scale=qcd_z_scale_nos,
            qcd_others_scale=qcd_others_scale_nos,
            z_scale=z_scale,
            z_scale_error=z_scale_error)

        qcd.data_scale = qcd_data_scale
        qcd.scale_error = qcd_data_scale_error
        ztt.scale = z_scale
        ztt.scale_error = z_scale_error

        if args.plot:
            # Draw the distribution after the fit
            draw_samples(hist_template, expr,
                model=[qcd, others, ztt],
                data=data,
                category=category,
                region=model_region,
                cuts=control_region,
                name=xaxis_label,
                output_name=after_name,
                show_ratio=True,
                systematics=SYSTEMATICS.values() if systematics else None,
                ravel=hist_template.GetDimension() > 1,
                integer=integer,
                xtick_formatter=xtick_formatter,
                xtick_rotation=xtick_rotation)
