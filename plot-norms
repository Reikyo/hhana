#!/usr/bin/env python

import os
from fnmatch import fnmatch
from rootpy.io import root_open
from rootpy.plotting.contrib import plot_corrcoef_matrix
from rootpy.utils.path import mkdir_p
from rootpy.extern.argparse import ArgumentParser
from root_numpy import matrix
import matplotlib.pyplot as plt
import logging

log = logging.getLogger(os.path.basename(__file__))
if not os.environ.get("DEBUG", False):
    log.setLevel(logging.INFO)
if hasattr(logging, 'captureWarnings'):
    logging.captureWarnings(True)

parser = ArgumentParser()
parser.add_argument('--name', default='combined')
parser.add_argument('file')
args = parser.parse_args()

# default minimizer options
import ROOT
ROOT.Math.MinimizerOptions.SetDefaultStrategy(1)
ROOT.Math.MinimizerOptions.SetDefaultMinimizer('Minuit2')


def plot_norms(result, path='', pattern='*_norm_*'):
    """
    Plot post-fit normalization factors
    """
    vals = []
    errors = []
    names = []
    # find all norms
    for param in result.floating_params_final:
        if fnmatch(param.name, pattern):
            vals.append(param.value)
            errors.append(param.error)
            names.append(param.name.replace('ATLAS_norm_', '').replace('_', ' '))
    # plot
    fig, ax = plt.subplots(figsize=(7, 5), dpi=100)
    ax.errorbar(vals, range(len(names)), xerr=errors, fmt='o')
    for x, y, error in zip(vals, range(len(names)), errors):
        plt.annotate('${0:.2f} \pm {1:.2f}$'.format(x, error),
                    textcoords='offset points', xytext=(0, 15),
                    bbox=dict(boxstyle='square,pad=0.5', fc='white', alpha=0.5),
                    xy=(x, y), ha='center', va='bottom')
    ax.plot([1., 1.], [-0.5, len(names) - 0.5], 'r--')
    ax.set_xlabel('Post-fit Normalization')
    ax.set_ylim(-0.5, len(names) - 0.5)
    ax.set_yticks(range(len(names)))
    ax.set_yticklabels(names)
    plt.tight_layout()
    for fmt in ('eps', 'png'):
        filename = os.path.join(output, 'norms.{0}'.format(fmt))
        log.info("writing {0}".format(filename))
        plt.savefig(filename)


def shorten_name(name):
    return name.replace('ATLAS_', '').replace('alpha_', '').replace('mmc1_mass_', '').replace('channel_', '').replace('gamma_', '').replace('_', ' ')


output = os.path.splitext(args.file)[0] + '_plots'
if not os.path.exists(output):
    mkdir_p(output)
rfile = root_open(args.file)
ws = rfile[args.name]
# unconditional fit
minim = ws.fit(print_level=-1)
result = minim.save()
plot_norms(result, path=output)

# plot correlation matrix
from matplotlib import pyplot as plt
import matplotlib.colors as mcolors
c = mcolors.ColorConverter().to_rgb


def make_colormap(seq):
    """Return a LinearSegmentedColormap
    seq: a sequence of floats and RGB-tuples. The floats should be increasing
    and in the interval (0,1).

    http://stackoverflow.com/questions/16834861/create-own-colormap-using-matplotlib-and-plot-color-scale
    """
    seq = [(None,) * 3, 0.0] + list(seq) + [1.0, (None,) * 3]
    cdict = {'red': [], 'green': [], 'blue': []}
    for i, item in enumerate(seq):
        if isinstance(item, float):
            r1, g1, b1 = seq[i - 1]
            r2, g2, b2 = seq[i + 1]
            cdict['red'].append([item, r1, r2])
            cdict['green'].append([item, g1, g2])
            cdict['blue'].append([item, b1, b2])
    return mcolors.LinearSegmentedColormap('CustomMap', cdict)

fig = plt.figure(figsize=(14, 14), dpi=200)
ax = fig.add_subplot(111)
plot_corrcoef_matrix(
    matrix(result.correlation_matrix),
    fields=[shorten_name(p.name) for p in result.floating_params_final],
    fontsize=7, cmap='jet', cmap_text=make_colormap([c('white'), 0.33, c('black'), 0.66, c('white')]), axes=ax)
plt.savefig(os.path.join(output, 'correlations.png'), bbox_inches='tight')
