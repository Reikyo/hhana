#!/usr/bin/env python

"""
This is the main driver script for the analysis
"""

from mva.cmd import get_parser

args = get_parser().parse_args()
year = args.year

# stdlib imports
import pickle
from pprint import pprint
import os

# rootpy imports
from rootpy.plotting import Hist
from rootpy.tree import Cut
from rootpy.io import root_open as ropen

# root imports
import ROOT

# numpy imports
import numpy as np

# local imports
from mva.stats import hypotests
from mva.plotting import draw_scatter, draw_samples_array, draw_2d_hist
from mva.samples import Higgs
from mva.utils import make_multipage_pdf
from mva.classify import ClassificationProblem
from mva.systematics import get_systematics, iter_systematics
from mva.categories import CATEGORIES
from mva.massregions import MassRegions
from mva.variables import VARIABLES, WEIGHTS
from mva.analysis import Analysis
from mva.lumi import get_lumi_uncert
from mva import log, variables, plots_dir, samples

SYSTEMATICS = get_systematics(year)
PLOTS_DIR = plots_dir(__file__)
lumi_rel_error = get_lumi_uncert(year)
figures = {}
category_scores = {}

output_suffix = '_%sfit_%s' % (args.fit_param, args.qcd_shape_region)
if args.embedding:
    output_suffix += '_embedding'
if args.suffix:
    output_suffix += '_%s' % args.suffix
output_suffix += '_%d' % (year % 1E3)
output_suffix += '_%s' % args.categories
clf_output_suffix = output_suffix
if not args.systematics:
    output_suffix += '_statsonly'

mass_regions = MassRegions(
        low=args.low_mass_cut,
        high=args.high_mass_cut,
        high_sideband_in_control=args.high_sideband_in_control,
        mass_window_signal_region=args.mass_window_signal_region)

control_region = mass_regions.control_region
signal_region = mass_regions.signal_region
train_region = mass_regions.train_region

all_channels = {}
categories = CATEGORIES[args.categories]
category_names = args.category_names
target_region = args.target_region

analysis = Analysis(
    year=year,
    systematics=args.systematics,
    use_embedding=args.embedding,
    qcd_shape_region=args.qcd_shape_region)

if args.transform_scores:
    ClassificationProblem.TRANSFORM = True

for category in categories:
    
    if category_names is not None and category.name not in category_names:
        continue

    log.info("")
    log.info("=" * 40)
    log.info("%s category" % category.name)
    log.info("=" * 40)
    log.info("Cuts: %s" % analysis.ztautau.cuts(category, target_region))
    log.info("Weights: %s" % (', '.join(map(str, analysis.ztautau.get_weight_branches('NOMINAL')))))

    # apply normalization
    analysis.normalize(category, fit_param=args.fit_param)

    if 'yields' in args.actions:

        log.info("Signals:")
        for sample in analysis.signals:
            log.info("%s: %.4f (unweighted: %d)" % (sample.mode,
                sample.events(category, target_region),
                sample.events(category, target_region, raw=True)))
        model_events = 0.
        log.info("Backgrounds:")
        for sample in analysis.backgrounds:
            curr_model_events = sample.events(category, target_region)
            log.info("%s: %.4f (unweighted: %d)" % (
                sample.name, curr_model_events,
                sample.events(category, target_region, raw=True)))
            model_events += curr_model_events
        data_events = analysis.data.events(category, target_region)
        log.info("Data: %d" % data_events)
        log.info("Data / Model: %f" % (data_events / model_events))
       
    if 'plot' in args.actions:

        figures[category.name] = {}
        cuts = Cut(args.plot_cut)

        if args.plot_expr is not None:
            VARS = {tuple(args.plot_expr.split(',')):
                    {'title': args.plot_name,
                     'range': (args.plot_min, args.plot_max),
                     'bins': args.plot_bins,
                     'filename': 'expr_' + args.plot_name.replace(' ', '_')}}
        else:
            VARS = VARIABLES

        figs = draw_samples_array(
                vars=VARS,
                data=analysis.data,
                model=analysis.backgrounds,
                signal=[analysis.higgs_125],
                signal_scale=50,
                category=category,
                region=target_region,
                show_ratio=True,
                show_qq=False,
                plot_signal_significance=False,
                systematics=SYSTEMATICS if args.systematics else None,
                root=args.root,
                output_formats=args.output_formats,
                weighted=not args.no_weight,
                plots=args.plots,
                output_suffix=output_suffix,
                unblind=args.unblind,
                cuts=cuts)
        figures[category.name] = figs
    
    if 'weights' in args.actions:
        cuts = Cut(args.plot_cut)
        draw_samples_array(
                WEIGHTS,
                data=analysis.data,
                model=analysis.backgrounds,
                signal=[analysis.higgs_125],
                signal_scale=50,
                category=category,
                region=target_region,
                show_ratio=False,
                show_qq=False,
                plot_signal_significance=False,
                systematics=None,
                root=args.root,
                output_formats=args.output_formats,
                output_suffix=output_suffix,
                weighted=False,
                stacked_model=False,
                cuts=cuts)

    if 'train' in args.actions:
        
        # all modes, all masses
        signals_train = [
            Higgs(
                year=year,
                mass=125,
                modes=category.train_signal_modes,
                systematics=args.systematics),
        ]

        clf = ClassificationProblem(
                fields=category.features,
                category=category,
                region=target_region,
                clf_output_suffix=clf_output_suffix,
                output_suffix=output_suffix)
        
        clf.train(
                signals=signals_train,
                backgrounds=analysis.backgrounds,
                cuts=train_region,
                grid_search=args.grid_search,
                quick=args.quick_train,
                cv_nfold=args.nfold,
                use_cache=args.use_clf_cache)

    if '2d' in args.actions:
        log.info("plotting 2d mass vs classifier output")
        draw_2d_hist(clf,
                 category,
                 target_region,
                 analysis.backgrounds,
                 signals=analysis.signals,
                 data=analysis.data,
                 cuts=signal_region,
                 y='mass_mmc_tau1_tau2',
                 output_suffix=output_suffix)

    if 'correlate' in args.actions:
        log.info("drawing correlation matrices")
        # TODO
        # create correlation matrices for signal, background
        # and background and data in a control region

    if 'scatter' in args.actions:
        # show 2D plots of all input variables and with BDT output
        log.info("drawing scatter plots of input variables")
        draw_scatter(clf.all_fields,
                     category,
                     target_region,
                     output_suffix,
                     analysis.backgrounds,
                     data=analysis.data,
                     signals=analysis.signals,
                     signal_scale=300.,
                     classifier=clf if 'train' in args.actions else None,
                     unblind=args.unblind)

    if 'evaluate' in args.actions:
        # create BDT validation plots
        clf.evaluate(
                analysis,
                signal_region=signal_region,
                control_region=control_region,
                unblind=args.unblind,
                systematics=args.systematics,
                limitbins=category.limitbins,
                limitbinning=category.limitbinning,
                quick=args.quick_eval)

        #category_scores[category.name] = (bkg_scores, sig_scores)

    if 'limits' in args.actions:
        # TODO using the kylefix (in mva.stats.utils) determine the number of
        # bins that yields the best limit at 125
        channels = hypotests.optimized_channels(
                clf, category, target_region,
                analysis.backgrounds,
                data=analysis.data, 
                cuts=signal_region,
                mass_points=[125],
                systematics=args.systematics,
                lumi_rel_error=lumi_rel_error)
        
        """
        # construct a "channel" for each mass point
        channels = hypotests.channels(
                clf, category, target_region,
                analysis.backgrounds,
                data=analysis.data, 
                cuts=signal_region,
                bins=category.limitbins,
                binning=category.limitbinning,
                mass_points=[125],
                systematics=args.systematics)
        """

        for mass, channel in channels.items():
            if mass not in all_channels:
                all_channels[mass] = {}
            all_channels[mass][category.name] = channel


if 'limits' in args.actions:
    
    with ropen('limits%s.root' % output_suffix, 'recreate') as limits_file:
        for mass, category_channel in all_channels.items():
            channels = []
            # determine limits for each category separately
            for category, channel in category_channel.items():
                limit_hist = hypotests.get_limit(channel,
                        lumi_rel_error=lumi_rel_error)
                limit_hist.SetName("%s_%d" % (category, mass))
                limit_hist.Write()
                channels.append(channel)
            # determine limit with combined model
            limit_hist = hypotests.get_limit(channels,
                    lumi_rel_error=lumi_rel_error)
            limit_hist.SetName("combination_%d" % mass)
            limit_hist.Write()
